/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|* Op Declarations                                                            *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

#ifdef GET_OP_CLASSES
#undef GET_OP_CLASSES

class BroadcastAddOp;
class BroadcastAndOp;
class BroadcastAtan2Op;
class BroadcastCompareOp;
class BroadcastComplexOp;
class BroadcastDivOp;
class BroadcastMaxOp;
class BroadcastMinOp;
class BroadcastMulOp;
class BroadcastOrOp;
class BroadcastPowOp;
class BroadcastRemOp;
class BroadcastShiftLeftOp;
class BroadcastShiftRightArithmeticOp;
class BroadcastShiftRightLogicalOp;
class BroadcastSubOp;
class BroadcastXorOp;

//===----------------------------------------------------------------------===//
// xla_chlo::BroadcastAddOp declarations
//===----------------------------------------------------------------------===//

class BroadcastAddOpAdaptor {
public:
  BroadcastAddOpAdaptor(ValueRange values, DictionaryAttr attrs = nullptr);
  BroadcastAddOpAdaptor(BroadcastAddOp& op);
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ValueRange getODSOperands(unsigned index);
  Value lhs();
  Value rhs();
  DenseIntElementsAttr broadcast_dimensions();
  LogicalResult verify(Location loc);

private:
  ValueRange odsOperands;
  DictionaryAttr odsAttrs;
};
class BroadcastAddOp : public Op<BroadcastAddOp, OpTrait::ZeroRegion, OpTrait::OneResult, OpTrait::ZeroSuccessor, OpTrait::NOperands<2>::Impl, OpTrait::IsCommutative, MemoryEffectOpInterface::Trait, OpTrait::SameOperandsAndResultElementType, InferShapedTypeOpInterface::Trait> {
public:
  using Op::Op;
  using Adaptor = BroadcastAddOpAdaptor;
  static StringRef getOperationName();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  Operation::operand_range getODSOperands(unsigned index);
  Value lhs();
  Value rhs();
  ::mlir::MutableOperandRange lhsMutable();
  ::mlir::MutableOperandRange rhsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  Operation::result_range getODSResults(unsigned index);
  DenseIntElementsAttr broadcast_dimensionsAttr();
  Optional< DenseIntElementsAttr > broadcast_dimensions();
  void broadcast_dimensionsAttr(DenseIntElementsAttr attr);
  static void build(OpBuilder &builder, OperationState &result, Value left, Value  right, DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &odsBuilder, OperationState &odsState, Type resultType0, Value lhs, Value rhs, /*optional*/DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &odsBuilder, OperationState &odsState, ArrayRef<Type> resultTypes, Value lhs, Value rhs, /*optional*/DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &, OperationState &odsState, ArrayRef<Type> resultTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes);
  LogicalResult verify();
  static LogicalResult inferReturnTypeComponents(MLIRContext* context, Optional<Location> location, ValueRange operands, DictionaryAttr attributes, RegionRange regions, SmallVectorImpl<ShapedTypeComponents>& inferredReturnShapes);
  static ParseResult parse(OpAsmParser &parser, OperationState &result);
  void print(OpAsmPrinter &p);
  void getEffects(SmallVectorImpl<SideEffects::EffectInstance<MemoryEffects::Effect>> &effects);

    // TODO(laurenzo): It isn't clear to me why reifyReturnShapes does not
    // have its declaration generated by DeclareOpInterfaceMethods.
    LogicalResult reifyReturnTypeShapes(
         OpBuilder& builder, SmallVectorImpl<Value>& reifiedReturnShapes);
  
};

//===----------------------------------------------------------------------===//
// xla_chlo::BroadcastAndOp declarations
//===----------------------------------------------------------------------===//

class BroadcastAndOpAdaptor {
public:
  BroadcastAndOpAdaptor(ValueRange values, DictionaryAttr attrs = nullptr);
  BroadcastAndOpAdaptor(BroadcastAndOp& op);
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ValueRange getODSOperands(unsigned index);
  Value lhs();
  Value rhs();
  DenseIntElementsAttr broadcast_dimensions();
  LogicalResult verify(Location loc);

private:
  ValueRange odsOperands;
  DictionaryAttr odsAttrs;
};
class BroadcastAndOp : public Op<BroadcastAndOp, OpTrait::ZeroRegion, OpTrait::OneResult, OpTrait::ZeroSuccessor, OpTrait::NOperands<2>::Impl, OpTrait::IsCommutative, MemoryEffectOpInterface::Trait, InferShapedTypeOpInterface::Trait> {
public:
  using Op::Op;
  using Adaptor = BroadcastAndOpAdaptor;
  static StringRef getOperationName();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  Operation::operand_range getODSOperands(unsigned index);
  Value lhs();
  Value rhs();
  ::mlir::MutableOperandRange lhsMutable();
  ::mlir::MutableOperandRange rhsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  Operation::result_range getODSResults(unsigned index);
  DenseIntElementsAttr broadcast_dimensionsAttr();
  Optional< DenseIntElementsAttr > broadcast_dimensions();
  void broadcast_dimensionsAttr(DenseIntElementsAttr attr);
  static void build(OpBuilder &builder, OperationState &result, Value left, Value  right, DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &odsBuilder, OperationState &odsState, Type resultType0, Value lhs, Value rhs, /*optional*/DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &odsBuilder, OperationState &odsState, ArrayRef<Type> resultTypes, Value lhs, Value rhs, /*optional*/DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &, OperationState &odsState, ArrayRef<Type> resultTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes);
  LogicalResult verify();
  static LogicalResult inferReturnTypeComponents(MLIRContext* context, Optional<Location> location, ValueRange operands, DictionaryAttr attributes, RegionRange regions, SmallVectorImpl<ShapedTypeComponents>& inferredReturnShapes);
  static ParseResult parse(OpAsmParser &parser, OperationState &result);
  void print(OpAsmPrinter &p);
  void getEffects(SmallVectorImpl<SideEffects::EffectInstance<MemoryEffects::Effect>> &effects);

    // TODO(laurenzo): It isn't clear to me why reifyReturnShapes does not
    // have its declaration generated by DeclareOpInterfaceMethods.
    LogicalResult reifyReturnTypeShapes(
         OpBuilder& builder, SmallVectorImpl<Value>& reifiedReturnShapes);
  
};

//===----------------------------------------------------------------------===//
// xla_chlo::BroadcastAtan2Op declarations
//===----------------------------------------------------------------------===//

class BroadcastAtan2OpAdaptor {
public:
  BroadcastAtan2OpAdaptor(ValueRange values, DictionaryAttr attrs = nullptr);
  BroadcastAtan2OpAdaptor(BroadcastAtan2Op& op);
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ValueRange getODSOperands(unsigned index);
  Value lhs();
  Value rhs();
  DenseIntElementsAttr broadcast_dimensions();
  LogicalResult verify(Location loc);

private:
  ValueRange odsOperands;
  DictionaryAttr odsAttrs;
};
class BroadcastAtan2Op : public Op<BroadcastAtan2Op, OpTrait::ZeroRegion, OpTrait::OneResult, OpTrait::ZeroSuccessor, OpTrait::NOperands<2>::Impl, MemoryEffectOpInterface::Trait, OpTrait::SameOperandsAndResultElementType, InferShapedTypeOpInterface::Trait> {
public:
  using Op::Op;
  using Adaptor = BroadcastAtan2OpAdaptor;
  static StringRef getOperationName();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  Operation::operand_range getODSOperands(unsigned index);
  Value lhs();
  Value rhs();
  ::mlir::MutableOperandRange lhsMutable();
  ::mlir::MutableOperandRange rhsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  Operation::result_range getODSResults(unsigned index);
  DenseIntElementsAttr broadcast_dimensionsAttr();
  Optional< DenseIntElementsAttr > broadcast_dimensions();
  void broadcast_dimensionsAttr(DenseIntElementsAttr attr);
  static void build(OpBuilder &builder, OperationState &result, Value left, Value  right, DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &odsBuilder, OperationState &odsState, Type resultType0, Value lhs, Value rhs, /*optional*/DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &odsBuilder, OperationState &odsState, ArrayRef<Type> resultTypes, Value lhs, Value rhs, /*optional*/DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &, OperationState &odsState, ArrayRef<Type> resultTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes);
  LogicalResult verify();
  static LogicalResult inferReturnTypeComponents(MLIRContext* context, Optional<Location> location, ValueRange operands, DictionaryAttr attributes, RegionRange regions, SmallVectorImpl<ShapedTypeComponents>& inferredReturnShapes);
  static ParseResult parse(OpAsmParser &parser, OperationState &result);
  void print(OpAsmPrinter &p);
  void getEffects(SmallVectorImpl<SideEffects::EffectInstance<MemoryEffects::Effect>> &effects);

    // TODO(laurenzo): It isn't clear to me why reifyReturnShapes does not
    // have its declaration generated by DeclareOpInterfaceMethods.
    LogicalResult reifyReturnTypeShapes(
         OpBuilder& builder, SmallVectorImpl<Value>& reifiedReturnShapes);
  
};

//===----------------------------------------------------------------------===//
// xla_chlo::BroadcastCompareOp declarations
//===----------------------------------------------------------------------===//

class BroadcastCompareOpAdaptor {
public:
  BroadcastCompareOpAdaptor(ValueRange values, DictionaryAttr attrs = nullptr);
  BroadcastCompareOpAdaptor(BroadcastCompareOp& op);
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ValueRange getODSOperands(unsigned index);
  Value lhs();
  Value rhs();
  DenseIntElementsAttr broadcast_dimensions();
  StringAttr comparison_direction();
  LogicalResult verify(Location loc);

private:
  ValueRange odsOperands;
  DictionaryAttr odsAttrs;
};
class BroadcastCompareOp : public Op<BroadcastCompareOp, OpTrait::ZeroRegion, OpTrait::OneResult, OpTrait::ZeroSuccessor, OpTrait::NOperands<2>::Impl, MemoryEffectOpInterface::Trait, InferShapedTypeOpInterface::Trait> {
public:
  using Op::Op;
  using Adaptor = BroadcastCompareOpAdaptor;
  static StringRef getOperationName();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  Operation::operand_range getODSOperands(unsigned index);
  Value lhs();
  Value rhs();
  ::mlir::MutableOperandRange lhsMutable();
  ::mlir::MutableOperandRange rhsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  Operation::result_range getODSResults(unsigned index);
  DenseIntElementsAttr broadcast_dimensionsAttr();
  Optional< DenseIntElementsAttr > broadcast_dimensions();
  StringAttr comparison_directionAttr();
  StringRef comparison_direction();
  void broadcast_dimensionsAttr(DenseIntElementsAttr attr);
  void comparison_directionAttr(StringAttr attr);
  static void build(OpBuilder &builder, OperationState &result, Value lhs, Value rhs, DenseIntElementsAttr broadcast_dimensions, StringAttr comparison_direction);
  static void build(OpBuilder &odsBuilder, OperationState &odsState, Type resultType0, Value lhs, Value rhs, /*optional*/DenseIntElementsAttr broadcast_dimensions, StringAttr comparison_direction);
  static void build(OpBuilder &odsBuilder, OperationState &odsState, ArrayRef<Type> resultTypes, Value lhs, Value rhs, /*optional*/DenseIntElementsAttr broadcast_dimensions, StringAttr comparison_direction);
  static void build(OpBuilder &odsBuilder, OperationState &odsState, Type resultType0, Value lhs, Value rhs, /*optional*/DenseIntElementsAttr broadcast_dimensions, StringRef comparison_direction);
  static void build(OpBuilder &odsBuilder, OperationState &odsState, ArrayRef<Type> resultTypes, Value lhs, Value rhs, /*optional*/DenseIntElementsAttr broadcast_dimensions, StringRef comparison_direction);
  static void build(OpBuilder &, OperationState &odsState, ArrayRef<Type> resultTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes);
  LogicalResult verify();
  static LogicalResult inferReturnTypeComponents(MLIRContext* context, Optional<Location> location, ValueRange operands, DictionaryAttr attributes, RegionRange regions, SmallVectorImpl<ShapedTypeComponents>& inferredReturnShapes);
  static ParseResult parse(OpAsmParser &parser, OperationState &result);
  void print(OpAsmPrinter &p);
  void getEffects(SmallVectorImpl<SideEffects::EffectInstance<MemoryEffects::Effect>> &effects);

    // TODO(laurenzo): It isn't clear to me why reifyReturnShapes does not
    // have its declaration generated by DeclareOpInterfaceMethods.
    LogicalResult reifyReturnTypeShapes(
         OpBuilder& builder, SmallVectorImpl<Value>& reifiedReturnShapes);
  
};

//===----------------------------------------------------------------------===//
// xla_chlo::BroadcastComplexOp declarations
//===----------------------------------------------------------------------===//

class BroadcastComplexOpAdaptor {
public:
  BroadcastComplexOpAdaptor(ValueRange values, DictionaryAttr attrs = nullptr);
  BroadcastComplexOpAdaptor(BroadcastComplexOp& op);
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ValueRange getODSOperands(unsigned index);
  Value lhs();
  Value rhs();
  DenseIntElementsAttr broadcast_dimensions();
  LogicalResult verify(Location loc);

private:
  ValueRange odsOperands;
  DictionaryAttr odsAttrs;
};
class BroadcastComplexOp : public Op<BroadcastComplexOp, OpTrait::ZeroRegion, OpTrait::OneResult, OpTrait::ZeroSuccessor, OpTrait::NOperands<2>::Impl, MemoryEffectOpInterface::Trait, InferShapedTypeOpInterface::Trait> {
public:
  using Op::Op;
  using Adaptor = BroadcastComplexOpAdaptor;
  static StringRef getOperationName();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  Operation::operand_range getODSOperands(unsigned index);
  Value lhs();
  Value rhs();
  ::mlir::MutableOperandRange lhsMutable();
  ::mlir::MutableOperandRange rhsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  Operation::result_range getODSResults(unsigned index);
  DenseIntElementsAttr broadcast_dimensionsAttr();
  Optional< DenseIntElementsAttr > broadcast_dimensions();
  void broadcast_dimensionsAttr(DenseIntElementsAttr attr);
  static void build(OpBuilder &builder, OperationState &result, Value left, Value  right, DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &odsBuilder, OperationState &odsState, Type resultType0, Value lhs, Value rhs, /*optional*/DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &odsBuilder, OperationState &odsState, ArrayRef<Type> resultTypes, Value lhs, Value rhs, /*optional*/DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &, OperationState &odsState, ArrayRef<Type> resultTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes);
  LogicalResult verify();
  static LogicalResult inferReturnTypeComponents(MLIRContext* context, Optional<Location> location, ValueRange operands, DictionaryAttr attributes, RegionRange regions, SmallVectorImpl<ShapedTypeComponents>& inferredReturnShapes);
  static ParseResult parse(OpAsmParser &parser, OperationState &result);
  void print(OpAsmPrinter &p);
  void getEffects(SmallVectorImpl<SideEffects::EffectInstance<MemoryEffects::Effect>> &effects);

    // TODO(laurenzo): It isn't clear to me why reifyReturnShapes does not
    // have its declaration generated by DeclareOpInterfaceMethods.
    LogicalResult reifyReturnTypeShapes(
         OpBuilder& builder, SmallVectorImpl<Value>& reifiedReturnShapes);
  
};

//===----------------------------------------------------------------------===//
// xla_chlo::BroadcastDivOp declarations
//===----------------------------------------------------------------------===//

class BroadcastDivOpAdaptor {
public:
  BroadcastDivOpAdaptor(ValueRange values, DictionaryAttr attrs = nullptr);
  BroadcastDivOpAdaptor(BroadcastDivOp& op);
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ValueRange getODSOperands(unsigned index);
  Value lhs();
  Value rhs();
  DenseIntElementsAttr broadcast_dimensions();
  LogicalResult verify(Location loc);

private:
  ValueRange odsOperands;
  DictionaryAttr odsAttrs;
};
class BroadcastDivOp : public Op<BroadcastDivOp, OpTrait::ZeroRegion, OpTrait::OneResult, OpTrait::ZeroSuccessor, OpTrait::NOperands<2>::Impl, MemoryEffectOpInterface::Trait, OpTrait::SameOperandsAndResultElementType, InferShapedTypeOpInterface::Trait> {
public:
  using Op::Op;
  using Adaptor = BroadcastDivOpAdaptor;
  static StringRef getOperationName();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  Operation::operand_range getODSOperands(unsigned index);
  Value lhs();
  Value rhs();
  ::mlir::MutableOperandRange lhsMutable();
  ::mlir::MutableOperandRange rhsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  Operation::result_range getODSResults(unsigned index);
  DenseIntElementsAttr broadcast_dimensionsAttr();
  Optional< DenseIntElementsAttr > broadcast_dimensions();
  void broadcast_dimensionsAttr(DenseIntElementsAttr attr);
  static void build(OpBuilder &builder, OperationState &result, Value left, Value  right, DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &odsBuilder, OperationState &odsState, Type resultType0, Value lhs, Value rhs, /*optional*/DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &odsBuilder, OperationState &odsState, ArrayRef<Type> resultTypes, Value lhs, Value rhs, /*optional*/DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &, OperationState &odsState, ArrayRef<Type> resultTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes);
  LogicalResult verify();
  static LogicalResult inferReturnTypeComponents(MLIRContext* context, Optional<Location> location, ValueRange operands, DictionaryAttr attributes, RegionRange regions, SmallVectorImpl<ShapedTypeComponents>& inferredReturnShapes);
  static ParseResult parse(OpAsmParser &parser, OperationState &result);
  void print(OpAsmPrinter &p);
  void getEffects(SmallVectorImpl<SideEffects::EffectInstance<MemoryEffects::Effect>> &effects);

    // TODO(laurenzo): It isn't clear to me why reifyReturnShapes does not
    // have its declaration generated by DeclareOpInterfaceMethods.
    LogicalResult reifyReturnTypeShapes(
         OpBuilder& builder, SmallVectorImpl<Value>& reifiedReturnShapes);
  
};

//===----------------------------------------------------------------------===//
// xla_chlo::BroadcastMaxOp declarations
//===----------------------------------------------------------------------===//

class BroadcastMaxOpAdaptor {
public:
  BroadcastMaxOpAdaptor(ValueRange values, DictionaryAttr attrs = nullptr);
  BroadcastMaxOpAdaptor(BroadcastMaxOp& op);
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ValueRange getODSOperands(unsigned index);
  Value lhs();
  Value rhs();
  DenseIntElementsAttr broadcast_dimensions();
  LogicalResult verify(Location loc);

private:
  ValueRange odsOperands;
  DictionaryAttr odsAttrs;
};
class BroadcastMaxOp : public Op<BroadcastMaxOp, OpTrait::ZeroRegion, OpTrait::OneResult, OpTrait::ZeroSuccessor, OpTrait::NOperands<2>::Impl, OpTrait::IsCommutative, MemoryEffectOpInterface::Trait, OpTrait::SameOperandsAndResultElementType, InferShapedTypeOpInterface::Trait> {
public:
  using Op::Op;
  using Adaptor = BroadcastMaxOpAdaptor;
  static StringRef getOperationName();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  Operation::operand_range getODSOperands(unsigned index);
  Value lhs();
  Value rhs();
  ::mlir::MutableOperandRange lhsMutable();
  ::mlir::MutableOperandRange rhsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  Operation::result_range getODSResults(unsigned index);
  DenseIntElementsAttr broadcast_dimensionsAttr();
  Optional< DenseIntElementsAttr > broadcast_dimensions();
  void broadcast_dimensionsAttr(DenseIntElementsAttr attr);
  static void build(OpBuilder &builder, OperationState &result, Value left, Value  right, DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &odsBuilder, OperationState &odsState, Type resultType0, Value lhs, Value rhs, /*optional*/DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &odsBuilder, OperationState &odsState, ArrayRef<Type> resultTypes, Value lhs, Value rhs, /*optional*/DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &, OperationState &odsState, ArrayRef<Type> resultTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes);
  LogicalResult verify();
  static LogicalResult inferReturnTypeComponents(MLIRContext* context, Optional<Location> location, ValueRange operands, DictionaryAttr attributes, RegionRange regions, SmallVectorImpl<ShapedTypeComponents>& inferredReturnShapes);
  static ParseResult parse(OpAsmParser &parser, OperationState &result);
  void print(OpAsmPrinter &p);
  void getEffects(SmallVectorImpl<SideEffects::EffectInstance<MemoryEffects::Effect>> &effects);

    // TODO(laurenzo): It isn't clear to me why reifyReturnShapes does not
    // have its declaration generated by DeclareOpInterfaceMethods.
    LogicalResult reifyReturnTypeShapes(
         OpBuilder& builder, SmallVectorImpl<Value>& reifiedReturnShapes);
  
};

//===----------------------------------------------------------------------===//
// xla_chlo::BroadcastMinOp declarations
//===----------------------------------------------------------------------===//

class BroadcastMinOpAdaptor {
public:
  BroadcastMinOpAdaptor(ValueRange values, DictionaryAttr attrs = nullptr);
  BroadcastMinOpAdaptor(BroadcastMinOp& op);
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ValueRange getODSOperands(unsigned index);
  Value lhs();
  Value rhs();
  DenseIntElementsAttr broadcast_dimensions();
  LogicalResult verify(Location loc);

private:
  ValueRange odsOperands;
  DictionaryAttr odsAttrs;
};
class BroadcastMinOp : public Op<BroadcastMinOp, OpTrait::ZeroRegion, OpTrait::OneResult, OpTrait::ZeroSuccessor, OpTrait::NOperands<2>::Impl, OpTrait::IsCommutative, MemoryEffectOpInterface::Trait, OpTrait::SameOperandsAndResultElementType, InferShapedTypeOpInterface::Trait> {
public:
  using Op::Op;
  using Adaptor = BroadcastMinOpAdaptor;
  static StringRef getOperationName();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  Operation::operand_range getODSOperands(unsigned index);
  Value lhs();
  Value rhs();
  ::mlir::MutableOperandRange lhsMutable();
  ::mlir::MutableOperandRange rhsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  Operation::result_range getODSResults(unsigned index);
  DenseIntElementsAttr broadcast_dimensionsAttr();
  Optional< DenseIntElementsAttr > broadcast_dimensions();
  void broadcast_dimensionsAttr(DenseIntElementsAttr attr);
  static void build(OpBuilder &builder, OperationState &result, Value left, Value  right, DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &odsBuilder, OperationState &odsState, Type resultType0, Value lhs, Value rhs, /*optional*/DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &odsBuilder, OperationState &odsState, ArrayRef<Type> resultTypes, Value lhs, Value rhs, /*optional*/DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &, OperationState &odsState, ArrayRef<Type> resultTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes);
  LogicalResult verify();
  static LogicalResult inferReturnTypeComponents(MLIRContext* context, Optional<Location> location, ValueRange operands, DictionaryAttr attributes, RegionRange regions, SmallVectorImpl<ShapedTypeComponents>& inferredReturnShapes);
  static ParseResult parse(OpAsmParser &parser, OperationState &result);
  void print(OpAsmPrinter &p);
  void getEffects(SmallVectorImpl<SideEffects::EffectInstance<MemoryEffects::Effect>> &effects);

    // TODO(laurenzo): It isn't clear to me why reifyReturnShapes does not
    // have its declaration generated by DeclareOpInterfaceMethods.
    LogicalResult reifyReturnTypeShapes(
         OpBuilder& builder, SmallVectorImpl<Value>& reifiedReturnShapes);
  
};

//===----------------------------------------------------------------------===//
// xla_chlo::BroadcastMulOp declarations
//===----------------------------------------------------------------------===//

class BroadcastMulOpAdaptor {
public:
  BroadcastMulOpAdaptor(ValueRange values, DictionaryAttr attrs = nullptr);
  BroadcastMulOpAdaptor(BroadcastMulOp& op);
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ValueRange getODSOperands(unsigned index);
  Value lhs();
  Value rhs();
  DenseIntElementsAttr broadcast_dimensions();
  LogicalResult verify(Location loc);

private:
  ValueRange odsOperands;
  DictionaryAttr odsAttrs;
};
class BroadcastMulOp : public Op<BroadcastMulOp, OpTrait::ZeroRegion, OpTrait::OneResult, OpTrait::ZeroSuccessor, OpTrait::NOperands<2>::Impl, OpTrait::IsCommutative, MemoryEffectOpInterface::Trait, OpTrait::SameOperandsAndResultElementType, InferShapedTypeOpInterface::Trait> {
public:
  using Op::Op;
  using Adaptor = BroadcastMulOpAdaptor;
  static StringRef getOperationName();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  Operation::operand_range getODSOperands(unsigned index);
  Value lhs();
  Value rhs();
  ::mlir::MutableOperandRange lhsMutable();
  ::mlir::MutableOperandRange rhsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  Operation::result_range getODSResults(unsigned index);
  DenseIntElementsAttr broadcast_dimensionsAttr();
  Optional< DenseIntElementsAttr > broadcast_dimensions();
  void broadcast_dimensionsAttr(DenseIntElementsAttr attr);
  static void build(OpBuilder &builder, OperationState &result, Value left, Value  right, DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &odsBuilder, OperationState &odsState, Type resultType0, Value lhs, Value rhs, /*optional*/DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &odsBuilder, OperationState &odsState, ArrayRef<Type> resultTypes, Value lhs, Value rhs, /*optional*/DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &, OperationState &odsState, ArrayRef<Type> resultTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes);
  LogicalResult verify();
  static LogicalResult inferReturnTypeComponents(MLIRContext* context, Optional<Location> location, ValueRange operands, DictionaryAttr attributes, RegionRange regions, SmallVectorImpl<ShapedTypeComponents>& inferredReturnShapes);
  static ParseResult parse(OpAsmParser &parser, OperationState &result);
  void print(OpAsmPrinter &p);
  void getEffects(SmallVectorImpl<SideEffects::EffectInstance<MemoryEffects::Effect>> &effects);

    // TODO(laurenzo): It isn't clear to me why reifyReturnShapes does not
    // have its declaration generated by DeclareOpInterfaceMethods.
    LogicalResult reifyReturnTypeShapes(
         OpBuilder& builder, SmallVectorImpl<Value>& reifiedReturnShapes);
  
};

//===----------------------------------------------------------------------===//
// xla_chlo::BroadcastOrOp declarations
//===----------------------------------------------------------------------===//

class BroadcastOrOpAdaptor {
public:
  BroadcastOrOpAdaptor(ValueRange values, DictionaryAttr attrs = nullptr);
  BroadcastOrOpAdaptor(BroadcastOrOp& op);
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ValueRange getODSOperands(unsigned index);
  Value lhs();
  Value rhs();
  DenseIntElementsAttr broadcast_dimensions();
  LogicalResult verify(Location loc);

private:
  ValueRange odsOperands;
  DictionaryAttr odsAttrs;
};
class BroadcastOrOp : public Op<BroadcastOrOp, OpTrait::ZeroRegion, OpTrait::OneResult, OpTrait::ZeroSuccessor, OpTrait::NOperands<2>::Impl, OpTrait::IsCommutative, MemoryEffectOpInterface::Trait, InferShapedTypeOpInterface::Trait> {
public:
  using Op::Op;
  using Adaptor = BroadcastOrOpAdaptor;
  static StringRef getOperationName();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  Operation::operand_range getODSOperands(unsigned index);
  Value lhs();
  Value rhs();
  ::mlir::MutableOperandRange lhsMutable();
  ::mlir::MutableOperandRange rhsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  Operation::result_range getODSResults(unsigned index);
  DenseIntElementsAttr broadcast_dimensionsAttr();
  Optional< DenseIntElementsAttr > broadcast_dimensions();
  void broadcast_dimensionsAttr(DenseIntElementsAttr attr);
  static void build(OpBuilder &builder, OperationState &result, Value left, Value  right, DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &odsBuilder, OperationState &odsState, Type resultType0, Value lhs, Value rhs, /*optional*/DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &odsBuilder, OperationState &odsState, ArrayRef<Type> resultTypes, Value lhs, Value rhs, /*optional*/DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &, OperationState &odsState, ArrayRef<Type> resultTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes);
  LogicalResult verify();
  static LogicalResult inferReturnTypeComponents(MLIRContext* context, Optional<Location> location, ValueRange operands, DictionaryAttr attributes, RegionRange regions, SmallVectorImpl<ShapedTypeComponents>& inferredReturnShapes);
  static ParseResult parse(OpAsmParser &parser, OperationState &result);
  void print(OpAsmPrinter &p);
  void getEffects(SmallVectorImpl<SideEffects::EffectInstance<MemoryEffects::Effect>> &effects);

    // TODO(laurenzo): It isn't clear to me why reifyReturnShapes does not
    // have its declaration generated by DeclareOpInterfaceMethods.
    LogicalResult reifyReturnTypeShapes(
         OpBuilder& builder, SmallVectorImpl<Value>& reifiedReturnShapes);
  
};

//===----------------------------------------------------------------------===//
// xla_chlo::BroadcastPowOp declarations
//===----------------------------------------------------------------------===//

class BroadcastPowOpAdaptor {
public:
  BroadcastPowOpAdaptor(ValueRange values, DictionaryAttr attrs = nullptr);
  BroadcastPowOpAdaptor(BroadcastPowOp& op);
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ValueRange getODSOperands(unsigned index);
  Value lhs();
  Value rhs();
  DenseIntElementsAttr broadcast_dimensions();
  LogicalResult verify(Location loc);

private:
  ValueRange odsOperands;
  DictionaryAttr odsAttrs;
};
class BroadcastPowOp : public Op<BroadcastPowOp, OpTrait::ZeroRegion, OpTrait::OneResult, OpTrait::ZeroSuccessor, OpTrait::NOperands<2>::Impl, MemoryEffectOpInterface::Trait, OpTrait::SameOperandsAndResultElementType, InferShapedTypeOpInterface::Trait> {
public:
  using Op::Op;
  using Adaptor = BroadcastPowOpAdaptor;
  static StringRef getOperationName();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  Operation::operand_range getODSOperands(unsigned index);
  Value lhs();
  Value rhs();
  ::mlir::MutableOperandRange lhsMutable();
  ::mlir::MutableOperandRange rhsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  Operation::result_range getODSResults(unsigned index);
  DenseIntElementsAttr broadcast_dimensionsAttr();
  Optional< DenseIntElementsAttr > broadcast_dimensions();
  void broadcast_dimensionsAttr(DenseIntElementsAttr attr);
  static void build(OpBuilder &builder, OperationState &result, Value left, Value  right, DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &odsBuilder, OperationState &odsState, Type resultType0, Value lhs, Value rhs, /*optional*/DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &odsBuilder, OperationState &odsState, ArrayRef<Type> resultTypes, Value lhs, Value rhs, /*optional*/DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &, OperationState &odsState, ArrayRef<Type> resultTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes);
  LogicalResult verify();
  static LogicalResult inferReturnTypeComponents(MLIRContext* context, Optional<Location> location, ValueRange operands, DictionaryAttr attributes, RegionRange regions, SmallVectorImpl<ShapedTypeComponents>& inferredReturnShapes);
  static ParseResult parse(OpAsmParser &parser, OperationState &result);
  void print(OpAsmPrinter &p);
  void getEffects(SmallVectorImpl<SideEffects::EffectInstance<MemoryEffects::Effect>> &effects);

    // TODO(laurenzo): It isn't clear to me why reifyReturnShapes does not
    // have its declaration generated by DeclareOpInterfaceMethods.
    LogicalResult reifyReturnTypeShapes(
         OpBuilder& builder, SmallVectorImpl<Value>& reifiedReturnShapes);
  
};

//===----------------------------------------------------------------------===//
// xla_chlo::BroadcastRemOp declarations
//===----------------------------------------------------------------------===//

class BroadcastRemOpAdaptor {
public:
  BroadcastRemOpAdaptor(ValueRange values, DictionaryAttr attrs = nullptr);
  BroadcastRemOpAdaptor(BroadcastRemOp& op);
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ValueRange getODSOperands(unsigned index);
  Value lhs();
  Value rhs();
  DenseIntElementsAttr broadcast_dimensions();
  LogicalResult verify(Location loc);

private:
  ValueRange odsOperands;
  DictionaryAttr odsAttrs;
};
class BroadcastRemOp : public Op<BroadcastRemOp, OpTrait::ZeroRegion, OpTrait::OneResult, OpTrait::ZeroSuccessor, OpTrait::NOperands<2>::Impl, MemoryEffectOpInterface::Trait, OpTrait::SameOperandsAndResultElementType, InferShapedTypeOpInterface::Trait> {
public:
  using Op::Op;
  using Adaptor = BroadcastRemOpAdaptor;
  static StringRef getOperationName();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  Operation::operand_range getODSOperands(unsigned index);
  Value lhs();
  Value rhs();
  ::mlir::MutableOperandRange lhsMutable();
  ::mlir::MutableOperandRange rhsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  Operation::result_range getODSResults(unsigned index);
  DenseIntElementsAttr broadcast_dimensionsAttr();
  Optional< DenseIntElementsAttr > broadcast_dimensions();
  void broadcast_dimensionsAttr(DenseIntElementsAttr attr);
  static void build(OpBuilder &builder, OperationState &result, Value left, Value  right, DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &odsBuilder, OperationState &odsState, Type resultType0, Value lhs, Value rhs, /*optional*/DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &odsBuilder, OperationState &odsState, ArrayRef<Type> resultTypes, Value lhs, Value rhs, /*optional*/DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &, OperationState &odsState, ArrayRef<Type> resultTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes);
  LogicalResult verify();
  static LogicalResult inferReturnTypeComponents(MLIRContext* context, Optional<Location> location, ValueRange operands, DictionaryAttr attributes, RegionRange regions, SmallVectorImpl<ShapedTypeComponents>& inferredReturnShapes);
  static ParseResult parse(OpAsmParser &parser, OperationState &result);
  void print(OpAsmPrinter &p);
  void getEffects(SmallVectorImpl<SideEffects::EffectInstance<MemoryEffects::Effect>> &effects);

    // TODO(laurenzo): It isn't clear to me why reifyReturnShapes does not
    // have its declaration generated by DeclareOpInterfaceMethods.
    LogicalResult reifyReturnTypeShapes(
         OpBuilder& builder, SmallVectorImpl<Value>& reifiedReturnShapes);
  
};

//===----------------------------------------------------------------------===//
// xla_chlo::BroadcastShiftLeftOp declarations
//===----------------------------------------------------------------------===//

class BroadcastShiftLeftOpAdaptor {
public:
  BroadcastShiftLeftOpAdaptor(ValueRange values, DictionaryAttr attrs = nullptr);
  BroadcastShiftLeftOpAdaptor(BroadcastShiftLeftOp& op);
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ValueRange getODSOperands(unsigned index);
  Value lhs();
  Value rhs();
  DenseIntElementsAttr broadcast_dimensions();
  LogicalResult verify(Location loc);

private:
  ValueRange odsOperands;
  DictionaryAttr odsAttrs;
};
class BroadcastShiftLeftOp : public Op<BroadcastShiftLeftOp, OpTrait::ZeroRegion, OpTrait::OneResult, OpTrait::ZeroSuccessor, OpTrait::NOperands<2>::Impl, MemoryEffectOpInterface::Trait, OpTrait::SameOperandsAndResultElementType, InferShapedTypeOpInterface::Trait> {
public:
  using Op::Op;
  using Adaptor = BroadcastShiftLeftOpAdaptor;
  static StringRef getOperationName();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  Operation::operand_range getODSOperands(unsigned index);
  Value lhs();
  Value rhs();
  ::mlir::MutableOperandRange lhsMutable();
  ::mlir::MutableOperandRange rhsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  Operation::result_range getODSResults(unsigned index);
  DenseIntElementsAttr broadcast_dimensionsAttr();
  Optional< DenseIntElementsAttr > broadcast_dimensions();
  void broadcast_dimensionsAttr(DenseIntElementsAttr attr);
  static void build(OpBuilder &builder, OperationState &result, Value left, Value  right, DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &odsBuilder, OperationState &odsState, Type resultType0, Value lhs, Value rhs, /*optional*/DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &odsBuilder, OperationState &odsState, ArrayRef<Type> resultTypes, Value lhs, Value rhs, /*optional*/DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &, OperationState &odsState, ArrayRef<Type> resultTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes);
  LogicalResult verify();
  static LogicalResult inferReturnTypeComponents(MLIRContext* context, Optional<Location> location, ValueRange operands, DictionaryAttr attributes, RegionRange regions, SmallVectorImpl<ShapedTypeComponents>& inferredReturnShapes);
  static ParseResult parse(OpAsmParser &parser, OperationState &result);
  void print(OpAsmPrinter &p);
  void getEffects(SmallVectorImpl<SideEffects::EffectInstance<MemoryEffects::Effect>> &effects);

    // TODO(laurenzo): It isn't clear to me why reifyReturnShapes does not
    // have its declaration generated by DeclareOpInterfaceMethods.
    LogicalResult reifyReturnTypeShapes(
         OpBuilder& builder, SmallVectorImpl<Value>& reifiedReturnShapes);
  
};

//===----------------------------------------------------------------------===//
// xla_chlo::BroadcastShiftRightArithmeticOp declarations
//===----------------------------------------------------------------------===//

class BroadcastShiftRightArithmeticOpAdaptor {
public:
  BroadcastShiftRightArithmeticOpAdaptor(ValueRange values, DictionaryAttr attrs = nullptr);
  BroadcastShiftRightArithmeticOpAdaptor(BroadcastShiftRightArithmeticOp& op);
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ValueRange getODSOperands(unsigned index);
  Value lhs();
  Value rhs();
  DenseIntElementsAttr broadcast_dimensions();
  LogicalResult verify(Location loc);

private:
  ValueRange odsOperands;
  DictionaryAttr odsAttrs;
};
class BroadcastShiftRightArithmeticOp : public Op<BroadcastShiftRightArithmeticOp, OpTrait::ZeroRegion, OpTrait::OneResult, OpTrait::ZeroSuccessor, OpTrait::NOperands<2>::Impl, MemoryEffectOpInterface::Trait, OpTrait::SameOperandsAndResultElementType, InferShapedTypeOpInterface::Trait> {
public:
  using Op::Op;
  using Adaptor = BroadcastShiftRightArithmeticOpAdaptor;
  static StringRef getOperationName();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  Operation::operand_range getODSOperands(unsigned index);
  Value lhs();
  Value rhs();
  ::mlir::MutableOperandRange lhsMutable();
  ::mlir::MutableOperandRange rhsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  Operation::result_range getODSResults(unsigned index);
  DenseIntElementsAttr broadcast_dimensionsAttr();
  Optional< DenseIntElementsAttr > broadcast_dimensions();
  void broadcast_dimensionsAttr(DenseIntElementsAttr attr);
  static void build(OpBuilder &builder, OperationState &result, Value left, Value  right, DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &odsBuilder, OperationState &odsState, Type resultType0, Value lhs, Value rhs, /*optional*/DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &odsBuilder, OperationState &odsState, ArrayRef<Type> resultTypes, Value lhs, Value rhs, /*optional*/DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &, OperationState &odsState, ArrayRef<Type> resultTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes);
  LogicalResult verify();
  static LogicalResult inferReturnTypeComponents(MLIRContext* context, Optional<Location> location, ValueRange operands, DictionaryAttr attributes, RegionRange regions, SmallVectorImpl<ShapedTypeComponents>& inferredReturnShapes);
  static ParseResult parse(OpAsmParser &parser, OperationState &result);
  void print(OpAsmPrinter &p);
  void getEffects(SmallVectorImpl<SideEffects::EffectInstance<MemoryEffects::Effect>> &effects);

    // TODO(laurenzo): It isn't clear to me why reifyReturnShapes does not
    // have its declaration generated by DeclareOpInterfaceMethods.
    LogicalResult reifyReturnTypeShapes(
         OpBuilder& builder, SmallVectorImpl<Value>& reifiedReturnShapes);
  
};

//===----------------------------------------------------------------------===//
// xla_chlo::BroadcastShiftRightLogicalOp declarations
//===----------------------------------------------------------------------===//

class BroadcastShiftRightLogicalOpAdaptor {
public:
  BroadcastShiftRightLogicalOpAdaptor(ValueRange values, DictionaryAttr attrs = nullptr);
  BroadcastShiftRightLogicalOpAdaptor(BroadcastShiftRightLogicalOp& op);
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ValueRange getODSOperands(unsigned index);
  Value lhs();
  Value rhs();
  DenseIntElementsAttr broadcast_dimensions();
  LogicalResult verify(Location loc);

private:
  ValueRange odsOperands;
  DictionaryAttr odsAttrs;
};
class BroadcastShiftRightLogicalOp : public Op<BroadcastShiftRightLogicalOp, OpTrait::ZeroRegion, OpTrait::OneResult, OpTrait::ZeroSuccessor, OpTrait::NOperands<2>::Impl, MemoryEffectOpInterface::Trait, OpTrait::SameOperandsAndResultElementType, InferShapedTypeOpInterface::Trait> {
public:
  using Op::Op;
  using Adaptor = BroadcastShiftRightLogicalOpAdaptor;
  static StringRef getOperationName();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  Operation::operand_range getODSOperands(unsigned index);
  Value lhs();
  Value rhs();
  ::mlir::MutableOperandRange lhsMutable();
  ::mlir::MutableOperandRange rhsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  Operation::result_range getODSResults(unsigned index);
  DenseIntElementsAttr broadcast_dimensionsAttr();
  Optional< DenseIntElementsAttr > broadcast_dimensions();
  void broadcast_dimensionsAttr(DenseIntElementsAttr attr);
  static void build(OpBuilder &builder, OperationState &result, Value left, Value  right, DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &odsBuilder, OperationState &odsState, Type resultType0, Value lhs, Value rhs, /*optional*/DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &odsBuilder, OperationState &odsState, ArrayRef<Type> resultTypes, Value lhs, Value rhs, /*optional*/DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &, OperationState &odsState, ArrayRef<Type> resultTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes);
  LogicalResult verify();
  static LogicalResult inferReturnTypeComponents(MLIRContext* context, Optional<Location> location, ValueRange operands, DictionaryAttr attributes, RegionRange regions, SmallVectorImpl<ShapedTypeComponents>& inferredReturnShapes);
  static ParseResult parse(OpAsmParser &parser, OperationState &result);
  void print(OpAsmPrinter &p);
  void getEffects(SmallVectorImpl<SideEffects::EffectInstance<MemoryEffects::Effect>> &effects);

    // TODO(laurenzo): It isn't clear to me why reifyReturnShapes does not
    // have its declaration generated by DeclareOpInterfaceMethods.
    LogicalResult reifyReturnTypeShapes(
         OpBuilder& builder, SmallVectorImpl<Value>& reifiedReturnShapes);
  
};

//===----------------------------------------------------------------------===//
// xla_chlo::BroadcastSubOp declarations
//===----------------------------------------------------------------------===//

class BroadcastSubOpAdaptor {
public:
  BroadcastSubOpAdaptor(ValueRange values, DictionaryAttr attrs = nullptr);
  BroadcastSubOpAdaptor(BroadcastSubOp& op);
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ValueRange getODSOperands(unsigned index);
  Value lhs();
  Value rhs();
  DenseIntElementsAttr broadcast_dimensions();
  LogicalResult verify(Location loc);

private:
  ValueRange odsOperands;
  DictionaryAttr odsAttrs;
};
class BroadcastSubOp : public Op<BroadcastSubOp, OpTrait::ZeroRegion, OpTrait::OneResult, OpTrait::ZeroSuccessor, OpTrait::NOperands<2>::Impl, MemoryEffectOpInterface::Trait, OpTrait::SameOperandsAndResultElementType, InferShapedTypeOpInterface::Trait> {
public:
  using Op::Op;
  using Adaptor = BroadcastSubOpAdaptor;
  static StringRef getOperationName();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  Operation::operand_range getODSOperands(unsigned index);
  Value lhs();
  Value rhs();
  ::mlir::MutableOperandRange lhsMutable();
  ::mlir::MutableOperandRange rhsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  Operation::result_range getODSResults(unsigned index);
  DenseIntElementsAttr broadcast_dimensionsAttr();
  Optional< DenseIntElementsAttr > broadcast_dimensions();
  void broadcast_dimensionsAttr(DenseIntElementsAttr attr);
  static void build(OpBuilder &builder, OperationState &result, Value left, Value  right, DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &odsBuilder, OperationState &odsState, Type resultType0, Value lhs, Value rhs, /*optional*/DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &odsBuilder, OperationState &odsState, ArrayRef<Type> resultTypes, Value lhs, Value rhs, /*optional*/DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &, OperationState &odsState, ArrayRef<Type> resultTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes);
  LogicalResult verify();
  static LogicalResult inferReturnTypeComponents(MLIRContext* context, Optional<Location> location, ValueRange operands, DictionaryAttr attributes, RegionRange regions, SmallVectorImpl<ShapedTypeComponents>& inferredReturnShapes);
  static ParseResult parse(OpAsmParser &parser, OperationState &result);
  void print(OpAsmPrinter &p);
  void getEffects(SmallVectorImpl<SideEffects::EffectInstance<MemoryEffects::Effect>> &effects);

    // TODO(laurenzo): It isn't clear to me why reifyReturnShapes does not
    // have its declaration generated by DeclareOpInterfaceMethods.
    LogicalResult reifyReturnTypeShapes(
         OpBuilder& builder, SmallVectorImpl<Value>& reifiedReturnShapes);
  
};

//===----------------------------------------------------------------------===//
// xla_chlo::BroadcastXorOp declarations
//===----------------------------------------------------------------------===//

class BroadcastXorOpAdaptor {
public:
  BroadcastXorOpAdaptor(ValueRange values, DictionaryAttr attrs = nullptr);
  BroadcastXorOpAdaptor(BroadcastXorOp& op);
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ValueRange getODSOperands(unsigned index);
  Value lhs();
  Value rhs();
  DenseIntElementsAttr broadcast_dimensions();
  LogicalResult verify(Location loc);

private:
  ValueRange odsOperands;
  DictionaryAttr odsAttrs;
};
class BroadcastXorOp : public Op<BroadcastXorOp, OpTrait::ZeroRegion, OpTrait::OneResult, OpTrait::ZeroSuccessor, OpTrait::NOperands<2>::Impl, OpTrait::IsCommutative, MemoryEffectOpInterface::Trait, InferShapedTypeOpInterface::Trait> {
public:
  using Op::Op;
  using Adaptor = BroadcastXorOpAdaptor;
  static StringRef getOperationName();
  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  Operation::operand_range getODSOperands(unsigned index);
  Value lhs();
  Value rhs();
  ::mlir::MutableOperandRange lhsMutable();
  ::mlir::MutableOperandRange rhsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  Operation::result_range getODSResults(unsigned index);
  DenseIntElementsAttr broadcast_dimensionsAttr();
  Optional< DenseIntElementsAttr > broadcast_dimensions();
  void broadcast_dimensionsAttr(DenseIntElementsAttr attr);
  static void build(OpBuilder &builder, OperationState &result, Value left, Value  right, DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &odsBuilder, OperationState &odsState, Type resultType0, Value lhs, Value rhs, /*optional*/DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &odsBuilder, OperationState &odsState, ArrayRef<Type> resultTypes, Value lhs, Value rhs, /*optional*/DenseIntElementsAttr broadcast_dimensions);
  static void build(OpBuilder &, OperationState &odsState, ArrayRef<Type> resultTypes, ValueRange operands, ArrayRef<NamedAttribute> attributes);
  LogicalResult verify();
  static LogicalResult inferReturnTypeComponents(MLIRContext* context, Optional<Location> location, ValueRange operands, DictionaryAttr attributes, RegionRange regions, SmallVectorImpl<ShapedTypeComponents>& inferredReturnShapes);
  static ParseResult parse(OpAsmParser &parser, OperationState &result);
  void print(OpAsmPrinter &p);
  void getEffects(SmallVectorImpl<SideEffects::EffectInstance<MemoryEffects::Effect>> &effects);

    // TODO(laurenzo): It isn't clear to me why reifyReturnShapes does not
    // have its declaration generated by DeclareOpInterfaceMethods.
    LogicalResult reifyReturnTypeShapes(
         OpBuilder& builder, SmallVectorImpl<Value>& reifiedReturnShapes);
  
};

#endif  // GET_OP_CLASSES

